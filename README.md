# EntWatch for Garry's Mod Zombie Escape
Самописный аддон для отслеживания материй на ZE картах

## Добавление конфига
Первые значение можно получить тут [Nide-GG](https://github.com/NiDE-gg/ZE-Configs/tree/master/cstrike/addons/sourcemod/configs/entwatch/maps) или по `"weapon_*"` через Notepad++

Но для `func_button`, `math_counter` и `pt_spawner` прийдется лезть в исходники карты.

По `hammerid` находим нашу материю. Далее по `targetname` находим либо `point_template`, где есть наш `targetname`, либо вручную находим `func_button`, берём оттуда `id` и записываем в конфиг `buttonid`.

В самой кнопке есть метод `OnPressed`, который вызывает `filter_activator_name` (1-й параметр - это `targetname`, также через поиск ищем). Внутри будет метод `OnPass`, ищем по имени кнопку и смотрим, что с ней происходит.
- Если там нет метода `Unlock` или есть `Kill`, то это одноразовая материя (`["mode"] = ENTWATCH_MODE_LIMITED_USES`).
- Если есть `Unlock`, то в 4-й параметре - это КД. Записываем в конфиг `cooldown` (`["mode"] = ENTWATCH_MODE_COOLDOWNS`, если нет `math_counter`).

И внимательно смотрим, если есть какая-то строчка, где 2-й параметр - это `Add`, `Substract` или `SetValue`, то переходим по нему. Это наш `math_counter` (также может находится и в `point_template`, но не обязательно). Также записываем `id` в конфиг `energyid` или `targetname` в конфиг `energyname`.
- Если внутри есть `OnHitMin`, то записываем в конфиг `["mode"] = ENTWATCH_MODE_COUNTER_FMIN_REACHED`
- А если `OnHitMax`, то записываем в конфиг `["mode"] = ENTWATCH_MODE_COUNTER_FMAX_REACHED`.
- Можно еще подтянуть `startvalue`, `min` и `max` в конфиг, но не обязательно.
- Если сильно впадлу, то можно записать эти значения в `maxuses` и выставить `["mode"] = ENTWATCH_MODE_LIMITED_USES`

Остальное написано в файле `template.lua`, что можно еще изменить.

## Как работает (вкратце)
Во время инициализации карты, используются три hook'а:

### InitPostEntityMap
Используется для очистки закешированных Энтити как на стороне сервера, так и на стороне клиента

### EntityKeyValue
Используется для ранней инициализации материи, но в данном hook Энтити еще полностью не инициализирован. Поэтому инициализация происходит, когда мы получаем заветный `hammerid`. Для `weapon_elite` - имя, КД, кол-во использований. Для `func_button` - особо ничего, кроме привязки оружия к кнопке. Для `math_counter` - инициализация переменных для дальнейшей работы.

### AcceptInput
Главный hook, где мы получаем все, что нам нужно для отслеживания `func_button` и `math_counter`. Для `func_button` - `Use`, `Lock`, `Unlock` и `Kill`. Здесь мы можем ограничить кол-во использований или увеличить/уменьшить КД, если карта не предусматривает такого (но прийдется повозиться с эффектами). Для `math_counter` - получение правильного значения.

> [!NOTE]
> И для полного отслеживание остаётся пара штрихов: подбирание оружия, дроп через команду/бинд, дроп при смерти и изменение имени для игрока (чтобы не могли использовать материю те, кто не владеет ею)

### WeaponEquip
Игрок подбирает материю. Если на этапе с `EntityKeyValue` материя не была привязана к `func_button` и/или `math_counter`, то привязываем. Изменяем имя для игрока, чтобы он мог использовать материю.
> [!CAUTION]
> а нужно ли? можно в "weapon_map_base" добавить метод `KeyValue`
> а потом вызывать через `ent:TriggerOutput("OnPlayerPickup", ply)`
> главное не забыть при дропе ресетнуть имя игрока
```
function ENT:KeyValue(k, v)
    -- 99% of all outputs are named 'OnSomethingHappened'.
    if string.Left(k, 2) == "On" then
        self:StoreOutput(k, v)
    end
end
```

### PlayerDroppedWeapon
Игрок выбрасывает материю. При жизни или при смерти. Ресетаем имя и оправляем информацию клиенту, что больше не нужно отслеживать эту материю.

### NET MESSAGES
На стороне сервера, принимает только одну команду, чтобы получить список материй для отслеживание.
На стороне клиента: очистка списка всех материй, добавление и удаление материи.
